# 1. 네트워크의 큰 그림

## 1-1. 네트워크의 기본구조

### 네트워크 토폴로지

네트워크는 노드와 간선으로 이루어진 자료구조라는 점에서 **그래프**의 형태를 띤다고 할 수 있다.

네트워크 상에서 노드와 노드 사이의 연결 구조는 **네트워크 토폴로지(network topology)** 라고 부른다. 노드가 어떻게 연결되고 배치되느냐에 따라 망형, 트리형, 링형 등의 유형으로 나눌 수 있다.

[그림](http://www.ktword.co.kr/test/view/view.php?no=356)

### 호스트

위의 네트워크 토폴로지에서 네트워크의 가장자리에 위치하면서 네트워크를 통해 주고받는 정보를 최초로 송신하고 최종 수신하는 노드를 **호스트(host)** 라고 부른다.

노트북과 구글 두 호스트가 각각 호스트로서 정보를 주고 받는다고 했을 때

1. 노트북이 구글의 서버 컴퓨터에게 웹 페이지를 가져다 달라는 요청을 보낸다.
2. 구글의 서버 컴퓨터가 노트북에게 웹 페이지로 응답한다.

이 과정에서 노트북처럼 **요청(request)** 을 보내는 호스트를 **클라이언트(client)** , 구글의 서버 컴퓨터처럼 **응답(response)** 을 보내는 호스트를 **서버(server)** 라고 한다.

네트워크를 그래프로 간주했을 때 중간에 위치한 노드, 즉 중간노드는 가장자리에 위치한 호스트가 주고받는 정보들을 안정적으로 전송하는 역할을 하는데, 이러한 장비들로는 **스위치**, **라우터**, **공유기** 등이 해당된다.

### LAN과 WAN

네트워크는 규모에 따라 LAN과 WAN 으로 나뉜다.

**LAN(Local Area Network)**: (근거리 네트워크) 가정이나 기업처럼 비교적 가까운 거리를 연결하는 한정된 공간에서의 네트워크. 모든 네트워크 기기들이 같은 LAN 네트워크 안에서만 정보를 주고받는 것이 아니라 LAN 간의 통신도 빈번하다.

**WAN(Wide Area Network)**: (원거리 네트워크) WAN 을 통해 LAN 간 통신이 이루어지며 인터넷을 가능하게 만드는 네트워크. WAN 은 일반적으로 KT, LG U+, SK 브로드밴드 처럼 **ISP(Internet Service Provider)** 라는 인터넷 서비스 업체가 구축하고 관리한다.

### 패킷 교환 네트워크

네트워크를 통해 주고받는 데이터는 한 번에 송수신되지 않고 여러 데이터로 쪼개져서 송수신되는데, 이렇게 네트워크를 통해 송수신되는 데이터의 단위를 **패킷(packet)** 이라고 한다. 오늘날의 네트워크는 패킷 단위로 주고받는 정보를 쪼개서 송수신하고 수신지에서 재조립하며 패킷을 주고받는 '패킷 교환 네트워크'가 대부분이다.

하나의 패킷은 **페이로드(payload)** 와 **헤더(header)** 로 구성되어 있으며, 때로는 **트레일러(trailer)** 라는 정보가 포함되기도 한다.

**페이로드(payload)**: 실제 데이터

**헤더(header), 트레일러(trailer)**: 부가 정보

### 주소의 개념과 전송 방식

**주소(address)**: 네트워크상 두 호스트가 패킷을 주고받을 때 서로를 특정할 수 있는 정보로, 패킷의 헤더에 명시된다. 대표적인 주소로는 IP 주소와 MAC 주소가 있다.

수신지를 특정 호스트 하나로 지정할 수도 있고, 네트워크 내 모든 호스트로 지정할 수도 있다.

**유니캐스트(unicast)**: 송신지와 수신지가 일대일로 메시지를 주고받는 방식

**브로드캐스트(broadcast)**: 네트워크 상의 모든 호스트에게 메시지를 전송하는 방식. 브로드캐스트가 전송되는 범위를 **브로드캐스트 도메인** 이라고 하며, 호스트가 같은 브로드캐스트 도메인에 속해 있는 경우에는 같은 LAN에 속해 있다고 간주한다.

이 밖에도 네트워크 내 동일 그룹에 속한 호스트에게만 전송하는 **멀티캐스트**, 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송하는 **애니캐스트** 등 다양한 송수신 방식이 있지만, 유니캐스트와 브로드캐스트가 가장 자주 언급된다.

## 1-2. 두 호스트가 패킷을 주고받는 과정 (프로토콜 & 네트워크 참조 모델)

네트워크 내의 호스트가 서로 주고받을 내용(패킷)을 이해하고 올바르게 주고 받기 위해서는 해당 정보를 이해하기 위한 규칙인 **프로토콜** 과 **네트워크 참조 모델** 이 필요하다.

> 이번 장에서 알아볼 내용은 `프로토콜` 과 `네트워크 참조 모델` 이 두가지 틀에서 거의 모든게 진행된다.

### 프로토콜

호스트 뿐만 아니라 패킷이 거쳐 갈 네트워크 장비 역시 패킷의 내용을 이해할 수 있어야 하는데, 이를 위해 정한 규칙이 바로 프로토콜이다.

**프로토콜(protocol)**: 네트워크에서 통신을 주고 받는 노드 간의 합의된 규칙이나 방법을 말한다. 호스트와 네트워크 장비들이 서로 주고받는 정보를 이해하려면 같은 프로토콜로 통신해야 한다.

이번 장에서 알아볼 프로토콜 들의 예시:

```
IP	ARP	ICMP	TCP	UDP
DHCP	DNS	HTTP	SSL/TLS	HTTPS
...
```

각각의 프로토콜들은 다른 **목적**과 **특징**을 가진다.

### 네트워크 참조 모델

**네트워크 참조 모델(network reference model)**: 패킷을 주고받는 과정을 단계적이고 계층적으로 표현한 것. 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들인다.

네트워크 참조 모델에서 각각의 계층이 하는 일은 명확하게 정해져 있다. 따라서 계층별 목적에 맞는 프로토콜과 장비를 구성하면 네트워크의 구성과 설계, 문제의 진단과 해결이 용이해진다.

대표적인 네트워크 참조 모델로 **OSI 모델** 과 **TCP/IP** 모델이 있다.

### OSI 모델

**OSI 모델**: 국제 표준화 기구(ISO, International Organization for Standardization)에서 만든 네트워크 참조 모델로, 통신 단계를 7개의 계층으로 나눠 OSI 7 계층이라고 부른다.

[그림](https://medium.com/harrythegreat/osi%EA%B3%84%EC%B8%B5-tcp-ip-%EB%AA%A8%EB%8D%B8-%EC%89%BD%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-f308b1115359)

1. **물리 계층(physical layer)**: 가장 최하의 계층으로, 비트 신호를 주고받는 계층. 컴퓨터는 0과 1만을 이해할 수 있기 때문에 네트워크를 통해 주고받는 정보 또한 0과 1로 이루어진 신호로 구성된다.
2. **데이터 링크 계층(data link layer)**: 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층. 이를 위해 같은 네트워크에 속한 호스트를 식별할 수 있는 주소(MAC 주소)를 사용하고, 물리 계층을 통해 주고받는 정보에 오류가 없는지 확인하기도 한다.
3. **네트워크 계층(network layer)**: LAN 을 넘어 다른 네트워크와 통신을 주고받기 위한 계층. 따라서 네트워크간 통신 과정에서 호스트를 식별할 수 있는 IP 주소가 필요하며, 이 계층에서 사용되는 대표적인 프로토콜이 IP이다.
4. **전송 계층(transport layer)**: 네트워크간 송수신되는 패킷이 유실되거나 순서가 뒤바뀔 때를 대비해 신뢰성 있는 전송을 가능하게 하는 계층. 또한 포트(port) 라는 정보를 통해 특정 응용 프로그램과의 연결 다리 역할을 수행하는 계층이기도 하며, 전송 계층에 속한 대표적인 프로토콜에는 TCP와 UDP가 있다.
5. **세션 계층(session layer)**: 응용 프로그램 간의 연결 상태인 세션(session)을 관리하기 위한 계층. 응용프로그램 간의 연결 상태를 유지하거나 새롭게 생성하고, 필요하다면 연결을 끊는 역할을 한다.
6. **표현 계층(presentation layer)**: 인코딩, 압축, 암호화와 같은 작업을 구행하는 계층. 세션 계층과 표현 계층은 다른 계층과 달리 두 계층을 명확하게 구분하지 않거나 응용 계층에 포함하여 간주하는 경우가 많다.
7. **응용 계층(application layer)**: 사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 제공하는 계층으로 HTTP, HTTPS, DNS 등의 프로토콜이 응용 계층에 속한다.

### TCP/IP 모델

OSI 모델이 주로 네트워크의 이론적 기술을 목적으로 사용하는 반면, **TCP/IP 모델**은 구현과 프로토콜에 중점을 둔 네트워크 참조 모델이다. **TCP/IP 4계층** 이라고도 불리며 네트워크 액세스 계층, 인터넷 계층, 전송 계층, 응용 계층으로 구성되어 있다.

1. **네트워크 액세스 계층(network access layer)**: **링크 계층(link layer)**, **네트워크 인터페이스 계층(network interface layer)** 이라고도 불리며, OSI 모델의 데이터 링크 계층과 유사하다. TCP/IP 모델에는 OSI 모델에서의 물리 계층에 해당하는 개념이 없다고 보는 견해도 있다.
2. **인터넷 계층(internet layer)**: OSI 모델의 네트워크 계층과 유사하다.
3. **전송 계층(transport layer)**: OSI 모델에서 전송 계층과 유사하다.
4. **응용 계층(application layer)**: OSI 모델의 세션 계층, 표현 계층, 응용 계층을 합친 것과 유사하다.

### TCP/IP 모델 확장 (이 장의 관점)

여기서는 다른 여러 전공 서적에서 서술하는 방식을 차용하여 TCP/IP 모델에 물리 계층을 추가한 확장된 모델로써 네트워크를 설명한다. 유무선 통신 매체를 통해 신호를 주고받는 '물리 계층'부터 사용자 및 사용자 프로그램과 가장 가까이 맞닿아 있는 '응용 계층'까지 점차 계층을 올라가며 설명할 계획이다.

[그림](https://21stopa.blogspot.com/2014/02/ccna-osi-osi-7.html)

### 캡슐화와 역캡슐화

프로토콜과 네트워크 참조 모델을 토대로 이뤄지는 패킷의 송수신 과정 중 송신 과정에서는 캡슐화가 이루어지고, 수신 과정에서 역캡슐화가 이루어진다. 각 계층에서는 어떤 정보를 송신할 때 상위 계층으로부터 내려받은 패킷을 페이로드 삼아, 각 계층에 포함된 프로토콜의 각기 다른 목적과 특징에 따라 헤더 혹은 트레일러를 덧붙인 다음 하위 계층으로 전달한다.

**캡슐화(encapsulation)**: 상위 계층의 패킷이 하위 계층의 페이로드로 간주되어 송신 과정에서 헤더(및 트레일러)를 추가해 나가는 과정

**역캡슐화(decapsulation)**: 캡슐화 과정에서 붙인 헤더(및 트레일러)를 각 계층에서 확인한 뒤 제거하는 과정

OSI모델 기준 계층마다 패킷을 부르는 이름. (각 계층에서 주고받는 패킷(메시지)을 지칭하는 이름이 다르다.)

| 계층             | 패킷의 이름                                                                                |
| :--------------- | :----------------------------------------------------------------------------------------- |
| 그 이상의 계층   | **데이터(data)** 또는 **메시지(message)**                                     |
| 전송 계층        | TCP기반 패킷:**세그먼트(segment)**<br />UDP기반 패킷: **데이터그램(datagram)** |
| 네트워크 계층    | **패킷**(이하 IP 패킷) 또는 데이터그램                                               |
| 데이터 링크 계층 | **프레임(frame)**                                                                    |
| 물리 계층        | **심볼(symbol)** 또는 **비트(bit)**                                           |

네트워크 계층 구조상 캡슐화와 역캡슐화 과정

# 2. 물리계층과 데이터 링크 계층

목차:

1. 이더넷
2. 이더넷 프레임
3. 통신 매체
4. 네트워크 장비 (네트워크 인터페이스: NIC, 허브와 스위치)

## 2-1. 이더넷

물리 계층과 데이터 링크 계층에는 LAN 내의 호스트들이 올바르게 정보를 주고받을 수 있게 해주는 다양한 기술들이 포함되어 있는데, 그 기술의 예시가 이더넷이다.

**이더넷(Ethernet)**: 통신 매체를 통해 신호를 송수신하는 방법, 데이터 링크 계층에서 주고받는 데이터(프레임) 형식 등이 정의된 기술. 현대 대부분의 (유선)LAN은 이더넷을 기반으로 구현되어 있다.

이더넷 표준에 관한 내용은 지면상 생략

## 2-2. 이더넷 프레임

**이더넷 프레임(Ethernet frame)**: 이더넷 기반의 네트워크에서 주고받는 프레임을 말한다.

1~3: 헤더, 4: 페이로드, 5: 트레일러

1. **프리앰블(preamble)**: 송수신지 동기화를 위해 사용되는 8바이트 크기의 정보로, 프리앰블의 첫 7바이트는 `10101010` 이라는 값을 갖고, 마지막 바이트는 `10101011` 이라는 값을 갖는다. 수신지는 이 프리앰블 비트를 통해 현재의 이더넷 프레임이 수신되고 있다는 사실을 알게 된다.
2. **MAC 주소(mac address)**: 송신지와 수신지를 특정할 수 있는 6바이트 길이의 MAC 주소가 명시되며, 다음과 같이 콜론(:)으로 구분된 12자리 16진수로 구성되어 있다. `ab:cd:ab:cd:00:01`
3. **타입/길이(type/length)**: 이 필드에 명시된 크기가 1500 이하 (16진수 05DC)이면 이 필드는 프레임의 길이를 나타내고, 1536 이상 (16진수 0600) 이면 타입을 나타낸다. 타입은 캡슐화된 상위 계층의 정보를 의미하기 때문에 어떤 상위 계층 프로토콜이 캡슐화되었는지 알 수 있는데, IPv4가 캡슐화되있다면 이 필드에는 16진수 0800이 명시되있고, ARP 프로토콜이 캡슐화되있다면 이 필드에는 16진수 0806이 명시된다.
4. **데이터**: 데이터 필드에는 페이로드가 명시된다. 데이터의 최대크기는 1500바이트로 제한되어 있으며, 이 크기를 **MTU**라고 부른다.
5. **FCS(Frame Check Sequence)**: 프레임의 오류가 있는지의 여부를 확인하기 위한 필드로, **CRC(Cyclic Redundancy Check)** 라는 오류 검출용 값이 명시된다.

## 2-3. 유무선 통신 매체

### 유선 매체 - 트위스티드 페어 케이블

**트위스티드 페어 케이블(twisted pair cable)**: 두 가닥씩 꼬아져 있는 구리선을 통해 전기적으로 신호를 주고받는 통신 매체. 트위스티드 페어 케이블의 성능은 카테고리에 따라 Cat5(100Mbps), Cat6(1Gbps), ... Cat8(40Gbps) 로 나뉜다. 잡음(노이즈)을 줄이기 위해 철사나 포일로 감싸는 경우가 많으며, 포일 실드로 노이즈를 감소시킨 케이블을 **FTP(Foil Twisted Pair)** 케이블, 아무것도 감싸지 않은 케이블은 **UTP(Unshielded Twisted Pair)** 케이블이라고 부른다.

### 무선 매체 - 전파와 WiFi

대표적인 유선 매체가 트위스티드 페어 케이블이라면, 대표적인 무선 매체는 **전파**다.전파는 약 3kHz 부터 3THz 사이의 진동수를 갖는 전자기파를 의미하며, 개발자가 전파 통신의 물리학적 원리를 이해해야 할 일은 많지 않지만 진동수 2.4GHz 와 5GHz 정도는 알아두는 것이 좋다.

이 때 같은 주파수 대역인 2.4GHz, 5GHz 에서 해당 주파수 대역을 사용하는 여러 무선 네트워크가 존재할 수 있는데, 같은 대역을 사용하는 서로 다른 무선 네트워크를 구분하기 위해 **채널(channel)** 이라는 하위 주파수 대역으로 세분화하고, 해당 채널 대역에서 무선 통신이 이루어진다. (20MHz 정도로 채널을 구분하는 것이 신호가 중첩될 여지가 없다.)

## 2-4. 네트워크 장비

### 네트워크 인터페이스: NIC

**네트워크 인터페이스(network interface)**: 네트워크 상에서 노드와 통신 매체가 연결되는 지점. 네트워크 인터페이스는 노드와 네트워크 사이의 통로와도 같다. 네트워크 인터페이스마다 물리적 주소라고 불리는 MAC 주소가 부여되고, **NIC(Network Interface Controller)** 라는 하드웨어가 네트워크 인터페이스의 역할을 담당하는 것이 일반적이다.

**NIC(Network Interface Controller)**:  통신 매체의 신호를 호스트가 이해하는 프레임으로 변환하거나 호스트가 이해하는 프레임을 통신 매체의 신호로 변환하는 역할을 수행한다. 네트워크 인터페이스 카드, 네트워크 어댑터, LAN 카드, 네트워크 카드, (이더넷 네트워크의 경우) 이더넷 카드 등 다양한 명칭으로 불린다.

### 허브와 스위치

허브와 스위치는 물리 계층과 데이터 링크 계층의 중간 노드이다. 허브는 오늘날 잘 사용하지 않지만 전이중/반이중 통신, 브로드캐스트 통신의 특징을 잘 보여주기 때문에 오늘날 많은 전공 서적에서 허브에 대해 설명한다.

#### 물리 계층의 허브

허브의 2가지 특징

1. 브로드캐스트: 허브는 전달 받은 신호를 어떠한 조작이나 판단도 하지 않고 모든 포트에 단순하게 신호를 내보낸다.
2. 반이중 통신: **반이중(half duplex)** 모드란 송신 또는 수신을 번갈아 가면서 수행해야 하는 통신 방식을 말한다(무전기처럼).

> **전이중(full duplex)**: 동시 송수신이 가능한 상태

> 만일 둘 이상의 호스트가 허브를 향해 동시에 메시지를 보내면 **충돌(collision)** 이 발생하며, 충돌이 발생할 수 있는 영역을 **콜리전 도메인(collision domain)** 이라고 한다.

#### 데이터 링크 계층의 스위치

**스위치(switch)** 는 허브의 한계를 보완하기 위한 네트워크 장비로, 스위치는 허브와 달리 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보내고, 전이중 모드를 지원하므로 허브와 비교해 콜리전 도메인이 좁다.

스위치의 2가지 특징:

1. **MAC 주소 학습 기능**: 스위치가 전달받은 신호를 원하는 포트에만 내보낼 수 있는 이유는 스위치에 **MAC 주소 학습** 기능이 있기 때문이다. 스위치는 프레임 속 MAC 주소를 토대로 어떤 포트에 어떤 MAC 주소의 호스트가 연결되어 있는지 파악하고, 이 정보를 **MAC 주소 테이블(MAC address table)** 이라고 한다.
2. **VLAN(Virtual LAN)**: 같은 스위치에 연결된 모든 호스트를 하나의 네트워크로 간주하지 않고, 여러 논리적인 네트워크로 나눌 수 있다.

# 3. 네트워크 계층 - IP

물리 계층과 데이터 링크 계층에 속한 기술 대부분은 LAN 을 위한 기술이다. LAN 을 넘어서 다른 네트워크와 통신을 주고 받으려면 네트워크 계층 이상의 기술이 필요한데, 여기서 특히 중요하게 사용되는 기술은 네트워크 계층의 가장 핵심적인 프로토콜이라고 할 수 있는 **IP(Internet Protocol)** 이다.

## 3-1. IP의 목적과 특징

IP의 목적은 크게 **주소 지정(addressing)** 과 **단편화(fragmentation) 두가지로 나뉜다.**

### 주소 지정

IP 패킷 헤더와 페이로드에는 여러 정보가 있는데, IP의 주소 지정과 관련된 필드는 송신지 IP 주소와 수신지 IP 주소 필드가 있다.

**옥텟(octet)**: 숫자당 8비트로 표현되는 0~255 범위의 10진수로 4개가 표기되는데, 각각의 10진수는 점으로 구분되고, 여기서 점으로 구분된 하나의 10진수를 **옥텟(octet)**이라고 한다. `192.168.0.1` 에서 '192', '168', '0', '1' 각각이 표현 가능한 옥텟이다.

**라우터(router)**: 서로 다른 네트워크에 속한 두 호스트가 네트워크 간 통신을 수행할 때, IP 주소를 바탕으로 목적지까지 IP 패킷을 전달하는 네트워크 장비. 라우터는 네트워크 계층의 핵심적인 장비로, 전달받은 패킷을 IP 주소를 기반으로 목적지까지 최적의 경로로 전달하는 역할을 수행한다.

### 단편화

**MTU(Maximum Transmission Unit)**: IP 단편화를 이해하려면 MTU 단위를 알아야 한다. MTU 는 말 그대로 최대 전송 단위를 의미하는데, 전송하고자 하는 IP 패킷의 크기가 MTU 단위보다 클 경우에는 패킷을 MTU 이하의 여러 패킷으로 쪼개서 전송하고, 이렇게 쪼개서 전송된 패킷들은 수신지에서 재조합된다. 일반적으로 MTU 크기는 1500바이트이다.

IP 패킷 헤더에서 단편화와 관련된 필드는 식별자, 플래그, 단편화 오프셋이 있다.

1. **식별자(identifier)**: 특정 패킷이 어떤 데이터에서 쪼개진 패킷인지 식별하기 위해 사용되는 필드.
2. **플래그(flag)**: 3비트로 구성된 필드로, 첫 번째 비트를 제외한 나머지 2개의 비트는 각각 DF와 MF 라는 이름이 붙어 있다. 첫 번째 비트는 항상 0으로 설정되어 오늘날 사용되지 않고, DF는 'IP 단편화를 수행하지 말라(Don't Fragment). MF 는 단편화된 패킷이 더 있다(More Fragment)라는 표시를 남기기 위한 비트이다.

### 신뢰할 수 없는 통신과 비연결형 통신

IP의 두가지 특징은 '신뢰할 수 없는 통신'과 '비연결형 통신' 이라는 점이다.

1. **신뢰할 수 없는 프로토콜(unreliable protocol)**: 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜을 의미한다. 패킷이 유실되거나 목적지에 순서대로 전송되지 않더라도 이에 대한 조치를 취하지 않는 다는 것을 의미한다.
2. **비연결형 프로토콜(connectionless protocol)**: 패킷을 주고받기 전에 사전 연결 과정을 거치지 않는 다는 뜻이다. 상대 호스트의 수신 가능 여부는 고려하지 않고, 수신지를 향해 그저 패킷을 전송할 뿐이다.

이러한 특징은 빠른 패킷 전달을 가능하게 하지만 위 특징을 보완하기 위해 전송 계층의 주요 프로토콜인 TCP와 UDP의 존재 목적과도 직결된다.

## 3-2. IP 주소의 구조

IP 주소는 크게 **네트워크 주소** 와 **호스트 주소** 로 이루어져 있다.

### 클래스풀 주소 체계

중요한 점은 하나의 IP 주소에서 네트워크 주소를 표현하는 크기와 호스트를 표현하는 크기가 유동적일 수 있다는 점이다.

(A 클래스) NNN.HHH.HHH.HHH

(B 클래스) NNN.NNN.HHH.HHH

(C 클래스) NNN.NNN.NNN.HHH

N을 네트워크 주소의 공간, H를 호스트 주소의 공간이라고 했을 때 A 클래스에서 B 클래스로 갈 수록 네트워크당 적은 호스트에 IP 주소를 할당하게 된다.

A 클래스의 네트워크 주소 비트는 '0'으로 시작해 1옥텟으로 구성되고 호스트 주소는 3옥텟으로 구성, B 클래스의 네트워크 주소는 비트 '10'으로 시작해 2 옥텟으로 구성되고 호스트 주소도 2 옥텟으로 구성, C 클래스의 네트워크 주소는 비트 '110'으로 시작해 3옥텟으로 구성되며, 호스트 주소는 1옥텟으로 구성된다.

- A 클래스: 0.0.0.0 ~ 127.255.255.255
- B 클래스: 128.0.0.0 ~ 191.255.255.255
- C 클래스: 192.0.0.0 ~ 223.255.255.255

클래스별 IP 주소 표현의 가능 범위를 보면 알 수 있듯, 첫 옥텟의 주소만 보고도 A, B, C 클래스 중 어떤 클래스에 속한 IP 주소인지 알 수 있다.

### 클래스리스 주소 체계와 서브넷 마스크

위의 주소 체계 만으로는 전세계에 필요한 모든 호스트만큼의 IP 주소를 나눌 수 없기 때문에 더 정교하고 유동적으로 네트워크 영역을 나눌 수단이 필요한데, 그래서 등장한 개념이 **클래스리스 주소 체계(classless addressing)** 이다.

클래스 없이 IP 주소 내 네트워크 주소와 호스트 주소를 구분할 수 있어야 하는데, 이를 위해 **서브넷 마스크(subnet mask)** 를 사용한다. '192.168.200.102' 주소를 예로 들자면

IP주소:		11000000.10101000.11001000.01100110

서브넷 마스크:	11111111.11111111.11111111.00000000

서브넷 마스크에서 1에 해당하는 부분은 네트워크 주소, 0에 해당하는 부분은 호스트 주소로, '192.168.200.000' 은 네트워크 주소, '000.000.000.102' 는 호스트 주소이다. (IP 주소와 서브넷 마스크를 AND 연산 했을 경우 남는 부분은 네트워크 주소, 나머지는 호스트 주소)

> CIDR 표기 - 서브넷마스크 표기법
>
> 위의 경우 `192.168.200.102/24` 로 표기할 수 있다. **(IP주소/서브넷 마스크상의 1의 개수)** 이 표기법을 **CIDR 표기법(Classless Inter-Domain Routing notation)** 이라고 부르며, 앞의 24자리가 네트워크 주소, 나머지가 호스트 주소라는 의미이다. CIDR 표기는 꼭 옥텟 단위가 아닌 비트 단위로 네트워크와 호스트 주소를 구분시킬 수 있다. 위의 예시에서 서브넷 마스크의 1의 개수가 29라면 네트워크 주소는 `192.168.200.96`, 호스트 주소는 `0.0.0.6`. IP 주소중 마지막 세 자리만 호스트 주소고 나머지는 네트워크 주소이기 때문 (`0b110` 은 십진수로 6)

## 3-3. 공인 IP 주소와 사설 IP 주소

**공인 IP 주소**: 전 세계에서 고유한 IP 주소. 공인 IP 주소는 ISP나 공인 IP 주소 할당 기관을 통해 할당받을 수 있다.

**사설 IP 주소**: 외부 네트워크에 공개되지 않은 주소. 사설 IP 주소는 일반적으로 라우터(공유기)를 통해 할당되기 때문에 라우터(공유기)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당한다.

IP 주소 공간 중 사설 IP 주소로 사용하도록 특별히 예약된 IP 주소 공간이 있다. 다음의 예약 IP 주소 범위에 속하는 IP 주소는 사설 IP 주소로 간주하기로 약속된 주소다.

- 10.0.0.0/8 (10.0.0.0 ~ 10.255.255.255)
- 172.16.0.0/12 (172.16.0.0 ~ 172.31.255.255)
- 192.168.0.0/16 (192.168.0.0 ~ 192.168.255.255)

## 3-4. IP 주소의 할당

### 정적 할당

**정적 할당**: 수작업으로 IP 주소를 부여하는 방식. 정적 할당을 통해 할당된 IP 주소를 **정적 IP 주소(static IP address)** 라고 한다.일반적으로는 정적 IP 주소를 부여하고자 하는 IP 주소와 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소 등이 필요하다.

### 동적 할당: DHCP

**동적 할당**: 프로토콜을 통해 자동으로 IP 주소를 부여하는 방식. 동작 할당을 통해 할당된 IP 주소를 **동적 IP 주소(dynamic IP address)** 라고 한다. 이 과정에서 가장 흔히 사용되는 프로토콜은 **DHCP(Dynamic Host Configuration Protocol)** 이며, IP 주소를 할당받고자 하는 호스트는 **DHCP 서버**와 메시지를 주고받으며 동적 IP 주소를 할당받을 수 있다.

동적 IP 주소의 두가지 특징:

1. 동적 IP 주소에는 사용 가능한 기간(임대 기간)이 정해져 있다. <- **임대 갱신(lease renewal)** 가능
2. 동적 IP 주소는 할당받을 때마다 다른 주소를 받을 수 있다.

## 3-5. IP 전송 특징의 보완: ICMP

IP의 신뢰할 수 없는 프로토콜이자, 비연결형 프로토콜이라는 특징은 빠르기 때문에 반드시 보완해야 할 특징은 아니다. 하지만 그럼에도 불구하고 이 특징들을 보완해야 할 때가 있는데, 이를 위한 방법에는 크게 두 가지가 있다.

1. 신뢰할 수 있는 연결형 통신을 지원하는 상위 계층인 **TCP** 프로토콜을 이용.
2. 네트워크 계층의 **ICMP(Internet Control Message Protocol)** 이용.

> ICMP가 IP의 신뢰성을 완전히 보장하지는 않는다. ICMP 메시지 자체가 신뢰성을 완전히 보장하기 위해서는 전송 계층의 프로토콜이 필요하다.

ICMP 메시지는 크게 **전송 과정에서 발생한 오류 보고** 와 **네트워크에 대한 진단 정보(네트워크 상의 정보 제공)** 로 나눌 수 있다.

(아래 표가 전부는 아님)

| 유형                       | 메시지                                                                                                                                                                                                                                                                                                                                                                                                                  |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. 오류 보고               | - 네트워크 도달 불가(Destination network unreachable)<br />- 호스트 도달 불가(Destination host unreachable)<br />- 프로토콜 도달 불가, 수신지에서 특정 프로토콜을 사용할 수 없음 (Destination protocol unreachable)<br />- 포트 도달 불가(Destination port unreachable)<br />- 단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음 (Fragmentation required, and DF flag set)<br />- TTL 만료(TTL expired in transit) |
| 2. 네트워크 상의 정보 제공 | - Echo 요청(Echo request)<br />- Echo 응답(Echo reply)                                                                                                                                                                                                                                                                                                                                                                  |

IP 헤더에는 패킷의 수명을 의미하는 **TTL(Time To Live)** 필드가 있는데, 패킷이 라우터 하나를 거칠 때 마다 TTL 이 1씩 감소한다.

## 3-6. IP 주소와 MAC 주소의 대응: ARP

**ARP(Address Resolution Protocol)**: 상대 호스트의 IP 주소는 알고 MAC 주소는 모르는 경우, 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜. 네트워크 내의 모든 호스트에게 브로드캐스트 하여 알아냄. (이 IP 호스트와 통신하고 싶은데, 이 MAC 주소가 뭐냐고 소리치는 것과 같음) 이 정보는 **ARP 테이블(ARP Table)** 에 저장된다.

# 4. 전송 계층 - TCP와 UDP

네트워크 계층에서 가장 중요한 프로토콜이 IP 라면, 전송 계층에서 가장 중요한 프로토콜은 **TCP**와 **UDP**다.

## 4-1. TCP와 UDP의 목적과 특징

네트워크 계층에서 IP 주소와 MAC 주소를 통해 패킷을 송수신하는 호스트를 특정할 수 있지만, 사실 패킷의 최종 송수신 대상은 호스트가 아니라 **호스트가 실행하는 프로세스**다. 그리고 이 프로세스는 **포트(port)** 번호를 통해 식별할 수 있다. 그래서 IP 주소와 포트 번호는 다음과 같이 **IP 주소:포트 번호** 형식으로 함께 표기되는 경우가 많다.

`192.168.0.15:8000`

다음의 TCP 와 UDP 헤더를 살펴보면 TCP와 UDP 모두 포트 번호 필드인 송신지 포트 번호와 수신지 포트 번호를 포함하고 있다는 것을 알 수 있다.

**TCP 헤더**: 송신지 포트, 수신지 포트, 순서 번호, 확인 응답 번호, 데이터 오프셋, 예약, 제어 비트, 윈도우, 체크섬, 긴급 포인터, 옵션

**UDP 헤더**: 송신지 포트, 수신지 포트, 길이, 체크섬

> 참고: 포트 범위
>
> - **잘 알려진 포트 well known port (0 ~ 1023)**: 범용적으로 사용되는 프로토콜이 주로 사용하는 포트 번호 목록 (80의 HTTP, 22의 SSH 등)
> - **등록된 포트 registered port (1024 ~ 49151)**: 잘 알려진 포트에 비해 덜 범용적이지만 흔하게 사용되는 애플리케이션 프로토콜에 할당하기 위한 포트 번호이다. (3306의 MySQL, 8080의 HTTP 대체)
> - **사설 포트 private port, 임시 포트 ephemeral port, 동적 포트 dynamic port (49152 ~ 65535)**: 비교적 자유롭게 사용 가능한 포트

> **NAT(Network Address Translation)**: 네트워크 내부에서 사설 IP 주소를 사용하는 호스트가 네트워크 외부에 있는 호스트와 패킷을 주고 받기 위해 공인 IP 주소와 사설 IP 주소 간 변환에 사용하는 기술. 대부분의 라우터와 공유기는 NAT 기능을 내장하고 있다.
>
> **NAPT(Network Address Port Translation)**: 변환할 IP 주소 쌍과 더불어 포트 번호도 함께 기록하고 변환함으로써 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유할 수 있도록 하는 NAT의 일종. NAPT는 네트워크 내부에서 사용할 IP 주소와 네트워크 외부에서 사용할 IP 주소를 N:1 로 관리할 수 있다는 점에서, 공인 IP 주소 수의 부족 문제ㄹ 개선하는 기술로도 간주되고 있다.

### (비)신뢰성과 (비)연결형 보장

**TCP**: 신뢰할 수 있는 프로토콜이자 연결형 프로토콜 -> 패킷을 주고받기 전에 연결 수립 과정을 거치며, 연결 수립 이후 패킷을 주고받을 때 신뢰성 보장을 위해 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 등의 각종 기능을 제공하며 패킷의 송수신이 모두 끝나면 연결을 종료한다.

**UDP**: 신뢰할 수 없는 프로토콜이자 비연결형 프로토콜 -> 연결의 수립이나 종료 단계를 거치지 않고, 신뢰성을 높이기 위한 기능들도 제공하지 않는다.

## 4-2. TCP의 연결부터 종료까지

**쓰리 웨이 핸드셰이크(three-way handshake)**: 세 단계로 이루어진 TCP의 연결 수립 과정을 뜻한다.

호스트 A가 호스트 B에게 처음 연결 요청을 보낸다고 가정해보자.

1. 송수신 방향 A -> B: SYN 세그먼트 전송 (세그먼트의 순서 번호에는 호트 A 의 순서 번호가 포함되어 있다.)
2. 송수신 방향 B -> A: SYN + ACK 세그먼트 전송 (세그먼트의 순서 번호에는 호스트 B의 순서 번호와 1에서 보낸 세그먼트에 대한 확인 응답 번호가 포함되어 있다.)
3. 송수신 방향 A -> B: ACK 세그먼트 전송 (세그먼트의 순서 번호에는 호스트 A의 순서 번호와 2에서 보낸 세그먼트에 대한 확인 응답 번호가 포함되어 있다.)

호스트 A처럼 처음 연결을 시작하는 과정을 **액티브 오픈(active open)** 이라고 하고, 호스트 B처럼 연결 요청을 수신한 뒤에 그에 대한 연결을 수립하는 과정은 **패시브 오픈(passive open)** 이라고 한다.

(자세한 쓰리 웨이 핸드셰이크 과정 및 TCP의 오류, 흐름, 혼잡 제어 과정은 415 ~ 430쪽 참고)

> TCP 의 중요한 특징은 상태를 유지한다는 점이다. TCP는 상태를 유지하고 관리하는 프로토콜이라는 점에서 **스테이트풀 프로토콜(stateful protocol)** 이라고 부르는데, 여기서 **상태(state)** 란 현재 어떤 통신 과정에 있는지 나타내는 정보를 말한다. 터미널에서 `$ netstat -a -p tcp` 명령어 입력 후 `State` 열에 있는 값들이 상태 정보들이다.

# 5. 응용 계층 - HTTP의 기초

응용 계층의 핵심은 **HTTP** 이며, 5절은 기초와 배경지식, 6절은 응용으로 나누어서 설명한다.

## 5-1. DNS와 URI/URL

**도메인 네임(domain name)**: IP 주소로는 특정 호스트의 특징을 나타내기도 어렵고, 호스트의 IP 주소는 언제든 바뀔 수 있기 때문에 `www.example.com`, `git.kernel.org` 와 같은 문자열 형태의 호스트 특정 정보로, 호스트의 IP 주소와 대응된다.

**DNS서버(DNS Server), 네임 서버(name server)**: 도메인 네임과 그에 대응하는 IP 주소를 관리하는 특별한 서버

### 전체 주소 도메인 네임(FQDN)

`www.example.com.` 에서

- www : 3단계 도메인
- example : 2단계 도메인
- com : 최상위 도메인 (com, net, org, kr, jp, cn, us 등이 있다.) (루트 도메인은 일반적으로 생략하기 때문에 최상위 도메인이라고 칭함.)
- 마지막 com 뒤에 '.' : 루트 도메인 (일반적으로 도메인 네임을 표기할 때 루트 도메인 '.' 은 생략한다.)

위의 도메인 네임을 모두 포함하는 도메인 네임을 **전체 주소 도메인 네임(Fully-Qualified Domain Name (FQDN))** 이라고 하며, 이 FQDN 을 알면 호스트를 식별할 수 있다.

이렇게 계층적으로 분산되어 있는 도메인 네임에 대한 관리 체계를 **도메인 네임 시스템(DNS, Domain Name System)** 이라고 부른다.

### 자원과 URI/URL

**자원(resource)**: 네트워크 상의 메시지를 통해 주고받는 최종 대상을 의미한다. 이는 HTML 파일이 될 수도 있고, 이미지나 동영상 파일이 될 수도 있으며, 텍스트 파일이 될 수도 있다. (두 호스트가 네트워크를 통해 서로 정보를 주고받을 때 송수신하는 대상)

**URI(Uniform Resource Identifier)**: 웹 상에서의 자원을 식별하기 위한 정보. 자원(Resoure)을 식별(Identifier)하는 통일된 방식(Uniform)

- URI 중 이름으로 자원을 식별하는 방식: **URN(Uniform Resource Name)**
- URI 중 위치로 자원을 식별하는 방식: **URL(Uniform Resource Locator)**

> 오늘날 인터넷 환경에서 URN 보다 URL 을 자원 식별에 더 많이 사용하므로 URL 에 대해 더 알아보도록 하겠다.

URL 예시: `foo://www.example.com:8042/over/there?name=ferret#nose`

1. scheme (`foo://`): scheme 은 자원에 접근하는 방법을 나타낸다. scheme 에서 명시할 수 있는 값은 매우 다양하지만, 일반적으로는 사용할 프로토몰이 명시되며 scheme 이 `http://` 일 경우 HTTP를 사용하여 자원에 접근함을 나타내고, `https://` 일 경우 HTTPS 를 사용하여 자원에 접근함을 나타낸다.
2. authority(`www.example.com:8042`): authority 에는 호스트를 특정할 수 있는 IP 주소나 도메인 네임이 명시된다. 콜론(:) 뒤에 포트 번호를 명시할 수도 있다.
3. path(`/over/there`): path 에는 자원이 위치하고 있는 경로가 명시된다. 슬래시를 기준으로 계층적으로 표현되며, 최상위 경로 또한 슬래시로 표현된다. 예시로 'http 프로토콜로 접근 가능한 도메인 네임 example.com 의 자원 중 /home/images/a.png 에 위치한 자원' 은 `http://example.com/home/images/a.png` 로 표현할 수 있다.
4. query(`?name=ferrot`): query 는 URL에 대한 매개변수 역할을 하는 문자열이다. 쿼리 문자열(query string), 쿼리 파라미터(query parameter) 등으로도 불리며 scheme, authority, path 만으로는 표현하기 어려운 추가정보와도 같다. 쿼리 문자열은 물음표로 시작되는 <키=값> 형태의 데이터로, 앰퍼샌드(&)를 사용하여 여러 쿼리 문자열을 연결할 수 있다.
   > 지역: location, 침실 수: rooms, 면적: size, 최소 가격: min_price 을 쿼리 파라미터로 검색하고자 할 때
   > http://example.com/search?location=seoul&rooms=2&size=100&min_price=200000 와 같이 검색할 수 있다.
   >
5. fragment(`#nose`): fragment 는 자원의 일부분, 자원의 한 조각을 가리키기 위한 정보이다. 일반적으로 HTML 파일과 같은 자원에서 특정 부분을 가리키는 데 사용된다.

> URN: URL은 자원의 위치가 변하면 유효하지 않지만 URN은 자원에 고유하 이름을 붙이는 이름 기반의 식별자이기 때문에 자원의 위치와 무관하게 자원을 식별할 수 있다는 장점이 있다. 다만 URN은 아직 URL만큼 널리 채택된 방식은 아니므로 자원을 식별할 URI로는 URN보다 URL을 더 많이 사용한다.
>
> 다음은 ISBN이 '0451450523' 인 도서를 나타내는 URN이다. `urn:isbn:0451450523`

## 5-2. HTTP의 특징과 메시지 구조

### HTTP의 특징

1. **요청 응답 기반 프로토콜**: HTTP는 기본적으로 요청 메시지를 보내는 클라이언트와 이에 대한 응답 메시지를 보내는 서버가 서로 요청 메시지와 응답 메시지를 주고받는 구조로 작동한다. 따라서 같은 HTTP 메시지라도 HTTP 요청 메시지와 HTTP 응답 메시지의 형태는 다르다.
2. **미디어 독립적 프로토콜**: 애플리케이션의 다양한 데이터를 네트워크를 통해 송수신한다는 목적에 걸맞게 HTTP는 HTTP 메시지를 통해 HTML, JPEG, PNG, JSON, XML, PDF 등 다양한 종류의 자원을 주고받을 수 있다.
3. **스테이트리스 프로토콜**: 서버는 HTTP 요청을 보낸 클라이언트 관련 상태를 기억하지 않는다. 일반적으로 HTTP 서버는 많은 클라이언트와 동시에 상호작용하는데, 이런 상황에서 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담이 된다.

   > HTTP 서버가 지켜야 할 중요하 설계 목표에는 **확장성(scalability)** 과 **견고성(robustness)** 이 있는데, 서버가 상태를 유지하지 않고 모든 요청을 독립적인 요청으로 처리하면 특정 클라이언트가 특정 서버에종속되지 않아 서버의 추가나 대체가 쉬워져 확장성을 높이고, 서버 중 하나가 문제가 생기더라도 쉽게 다른 서버로 대체할 수 있어 견고성을 높일 수 있다.
   >
4. **지속 연결 프로토콜**: 초기 HTTP1.0 이하에서는 TCP처럼 요청-응답을 주고 받을 때 마다 매번 새롭게 연결을 수립하고 종료해야 하는 비지속 연결 방식이였지만, HTTP1.1 이상에서는 한번 연결하면 종료할 때 까지 다시 연결할 필요 없이 요청-응답 메시지를 주고받을 수 있는 **지속 연결(persistent connection)** 기술을 제공한다. **킵 얼라이브(keep-alive)** 라고도 부른다.

### HTTP 메시지 구조

HTTP 메시지는 기본적으로 시작라인과 필드라인, 그리고 메시지 본문으로 이루어져 있다. 필드 라인은 여러 개가 존재할 수 있고, 메시지 본문은 없을 수 있다. 메시지 본문에는 HTTP 를 통해 주고받는 자원이 명시된다.

```
HTTP 메세지 = 	시작라인(줄바꿈) <- HTTP 요청 메시지일 경우: 요청 라인, HTTP 응답 메시지일 경우: 상태 라인
		필드라인 (줄바꿈) <- 0개 이상
		(줄바꿈)
		메시지 본문 <- 선택적

```

**시작 라인(start-line)** 으로 HTTP 메시지가 요청 메시지인지 응답 메시지인지 구분할 수 있는데, 시작 라인은 HTTP 메시지가 요청 메시지일 경우 **요청 라인(requested-line)**이 되고, 응답 메시지일 경우 **상태 라인(status line)** 이 된다.

**요청 라인** = `메서드 (공백) 요청 대상 (공백) HTTP 버전 (줄바꿈)`

**상태 라인** = `HTTP 버전 (공백) 상태 코드 (공백) 이유 구문(선택적) (줄바꿈)`

1. 요청 메시지 예시
   ```
   GET /example-page HTTP/1.1
   Host: www.example.com
   Accept: *
   ```
2. 응답 메시지 예시
   ```
   HTTP/1.1 200 OK
   Content-Type: text/html
   Content-Length: 648

   <!DOCTYPE html>
   <html>
   <head>
   	<title>Example Page</title>
   </head>
   <body>
   	<h1>Hello, World!</h1>
   </body>
   </html>
   ```

## 5-3. HTTP 메서드와 상태 코드

요청 라인에서는 **메서드**, 상태 라인에서는 **상태 코드** (와 그를 설명하는 **이유 구문**)이 핵심이다.

### HTTP 메서드

| HTTP 메서드      | 설명                                            |
| ---------------- | ----------------------------------------------- |
| **GET**    | 자원을 습득하기 위한 메서드                     |
| **HEAD**   | GET과 동일하나, 헤더만을 응답받는 메서드        |
| **POST**   | 서버로 하여금 특정 작업을 처리게끔 하는 메서드  |
| **PUT**    | 자원을 대체하기 위한 메서드                     |
| **PATCH**  | 자원에 대한 부분적 수정을 위한 메서드           |
| **DELETE** | 자원을 삭제하기 위한 메서드                     |
| CONNECT          | 자원에 대한 양방향 연결을 시작하는 메서드       |
| OPTIONS          | 사용 가능한 메서 등 통신 옵션을 확인하는 메서드 |
| TRACE            | 자원에 대한 루프백 테스트를 수행하는 메서드     |

### HTTP 상태 코드

상태 코드는 요청의 결과를 나타내는 3자리 정수로, 백의 자릿수를 기준으로 요청 결과의 유형을 나눌 수 있다. 다시 말해, 유사한 결과를 나타내는 상태 코드는 같은 백의 자릿수를 공유한다.

| col1               | col2                      |
| ------------------ | ------------------------- |
| 100번대(100 ~ 199) | 정보성 상태 코드          |
| 200번대(200 ~ 299) | 성공 상태 코드            |
| 300번대(300 ~ 399) | 리다이렉션 상태 코드      |
| 400번대(400 ~ 499) | 클라이언트 에러 상태 코드 |
| 500번대(500 ~ 599) | 서버 에러 상태 코드       |

[HTTP 상태 코드 Wiki 백과](https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C)

## 5-4. HTTP 주요 헤더

**HTTP 헤더**는 요청이나 응답에 관해서 부가적인 정보를 전달하는 HTTP 요청 또는 응답 필드입니다. 예를 들어, 요청 메시지는 헤더를 사용하여 선호하는 미디어 형식을 나타낼 수 있는 반면, 응답은 헤더를 사용하여 반환된 본문의 미디어 형식을 나타낼 수 있습니다. 헤더는 대소문자를 구분하지 않으며, 줄의 처음에서 시작하여 바로 뒤에 `':'`과 헤더에 의존성이 있는 값이 따라옵니다. 값은 다음 CR 또는 메시지의 마지막에서 끝납니다.

헤더 집합 예시:

```
304 Not Modified
Access-Control-Allow-Origin: *
Age: 2318192
Cache-Control: public, max-age=315360000
Connection: keep-alive
Date: Mon, 18 Jul 2016 16:06:00 GMT
Server: Apache
Vary: Accept-Encoding
Via: 1.1 3dc30c7222755f86e824b93feb8b5b8c.cloudfront.net (CloudFront)
X-Amz-Cf-Id: TOl0FEm6uI4fgLdrKJx0Vao5hpkKGZULYN2TWD2gAWLtr7vlNjTvZw==
X-Backend-Server: developer6.webapp.scl3.mozilla.com
X-Cache: Hit from cloudfront
X-Cache-Info: cached
```

[헤더: MDN Web Docs](https://developer.mozilla.org/ko/docs/Glossary/HTTP_header)

> HTTP 헤더는 종류가 많기 때문에 처음부터 모두 암기하려고 노력할 필요는 없다.

# 6. 응용 계층 - HTTP의 응용

앞선 절에서 HTTP의 기초와 메시지 구조에 대해 학습했으므로 이번에는 쿠키, 캐시, 콘텐츠 협상, 인증, 보안으로 대표되는 각종 HTTP 기반의 다양한 기술들에 대해 알아보겠다.

## 6-1. 쿠키

HTTP 는 스테이트리스 프로토콜이기 때문에 모든 HTTP 요청 메시지는 독립된 메시지로 간주된다. 그렇다면 '3일간 보지 않기' 와 같은 기능은 어떻게 구현할 수 있는 걸까?

**쿠키(Cookie)**: HTTP의 스테이트리스한 특성을 보완하기 위한 대표적 수단으로, 서버에서 생성되어 클라이언트 측에 저장되는 <이름, 값> 쌍 형태의 데이터이다.

크롬 브라우저의 [개발자 도구] 에서 [Application] - [Storage] - [Cookies] 항목에서 확인할 수 있다.

HTTP 응답 메시지의 Set-Cookie 헤더 예시:

```
Set-Cookie: sessionID=abc; Expires=Fri, 23 Aug 2024 09:00:00 GMT
```

## 6-2. 캐시

**캐시(Cache), 혹은 웹 캐시(Web Cache)** 는 컴퓨터 구조의 캐시 메모리처럼 응답받은 자원의 사본을 임시 저장하여 불필요한 대역폭 낭비와 응답 지연을 방지하는 기술이다. 가령 클라이언트가 서버로부터 10MB 크기의 이미지를 전달받았다고 가정했을 때, 이 자원의 사본을 임시 저장하면 추후 동일한 요청 메시지를 보내야 할 때 임시 저장된 사본을 재활용할 수 있고, 결과적으로 더 빠르게 자원에 접근할 수 있다.

> 캐시는 클라이언트(주로 웹 브라우저)에 저장되기도 하고, 클라이언트와 서버 사이에 위치한 중간 서버에 저장되기도 한다. 전자를 개인 전용 캐시(private cache)라고 하고, 후자를 공용 캐시(pulic cache)라고 한다.

대부분의 캐시 데이터는 유효기간이 설정되 있다. 그 이유는 클라이언트가 캐시를 참조하는 사이 서버의 원본 데이터가 변경되어 원본 데이터와 캐시된 사본 데이터 간의 일관성이 깨질 수 있기 때문이다. 캐시된 사본 데이터가 서버의 원본 데이터와 얼마나 유사한지의 정도를 **캐시 신선도(cache freshness)** 라고 표현한다.

캐시의 유효기간이 지난 다음에 다음과 같이 `If-Modified-Since` 헤더를 통해 원본 자원에 변경이 있는지 물은 뒤 200(OK) 코드를 받으면 새로 받은 자원으로 캐시를 변경하고, 304(Not Modified) 코드를 받으면 자원이 바뀌지 않았기 때문에 기존의 캐시에 있는 자원을 활용해도 된다.

```
GET /index.html HTTP/1.1
Host: www.example.com
If-Modified-Since: Fri, 23 Aug 2024 09:00:00 GMT
```

> 위 처럼 날짜 기반이 아닌 **엔티티 태그(Entity Tag)** 를 활용하기도 한다.(엔티티 태그 활용법 생략)

## 6-3. 콘텐츠 협상

클라이언트가 어떤 자원을 원하느냐에 따라 서버가 표현, 즉 송수신 가능한 자원의 형태가 달라질 수 있다.

[콘텐츠 협상 블로그](https://inpa.tistory.com/entry/HTTP-%F0%9F%8C%90-%EC%BD%98%ED%85%90%EC%B8%A0-%ED%98%91%EC%83%81Content-Negotiation-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

## 6-4. 보안: SSL/TLS와 HTTPS

[SSL/TLS 블로그](https://kanoos-stu.tistory.com/46)

# 7. 프록시와 안정적인 트래픽

[프록시와 로드 밸런싱, 스케일링](https://cbw1030.tistory.com/317)

## 7-1. 오리진 서버와 중간 서버: 포워드 프록시와 리버스 프록시

## 7-2. 고가용성: 로드 밸런싱과 스케일링

## 7-3. Nginx로 알아보는 로드 밸런싱
